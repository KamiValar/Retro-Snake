#include "stdafx.h"//主函数库
#include"conio.h"//_getcha用
#include<stdlib.h>
#include<Windows.h>//system函数
#define L 40//长
#define W 20//宽

struct dot//点的结构体形式
{
	int attribute;//该值为1则为食物，2墙壁，3蛇本体，4虚拟蛇头
	int num;//蛇身体的序号
	int dir;//指引值，判断下一点移动方向
}D[20][40] = { 0 };//20*40的方格

int n[1] = { 1 };//贪吃蛇长度
int*p = n;//贪吃蛇长度用指针表示
int rane()//辅助随机数判断函数
{
	int i = 1, j = 1, n = 0;
	for (i = 1; i < W - 1; i++)
	{
		for (j = 1; j < L - 1; j++)
		{
			if (D[i][j].attribute == 1)//若地图上仍然存在食物，返回-1
				n = -1;
		}
	}
	return(n);
}
void ran()//随机生成随机食物坐标
{
	int x = 0, y = 0, n = 0;
	x = rand() % 40;//创建随机x轴坐标
	y = rand() % 20;//创建随机y轴坐标
	n = rane();//辅助函数反回值
	if (n == 0)//不存在食物时
	{
		if (D[y][x].attribute == 0)//且这点坐标未被占用
			D[y][x].attribute = 1;
		else
			ran();//若该点被占用，重新输出ran
	}

}

//已完成
int put()//输入函数
{
	char y = '0';
	int r = 0;
	y = _getch();//不需要回车即可输入
	if (y == 'w')//输入w 返回1 余下同理
		r = 1;
	if (y == 's')
		r = -1;
	if (y == 'a')
		r = 2;
	if (y == 'd')
		r = -2;
	return(r);
}
//已完成
void judge()//指引值判断
{
	int x = 1, y = 1, m1 = 0, m2 = 0;//设置搜索范围
	int k = 2;//起始序号
	int i = 1, j = 1;//起始范围2
	for (k = 2; k <= *p; k++)//按序号排列
	{
		for (y = 1; y < W - 1; y++)//纵坐标1
		{
			for (x = 1; x < L - 1; x++)//横坐标1
			{
				if (D[y][x].num == k)//找到
				{
					m1 = y;
					m2 = x;
					break;
				}
			}
			if (D[y][x].num == k)
				break;
		}
		for (i = 1; i < W - 1; i++)//第二次循环纵坐标
		{
			for (j = 1; j < L - 1; j++)//第二次循环横坐标
			{
				if (D[i][j].num == k - 1)//找到序号为k-1
				{
					if (i - m1 == 1)//头坐标减去后一点坐标
					{
						D[m1][m2].dir = -1;//指引值为1，向上移动一个单位
						break;
					}
					if (i - m1 == -1)//指引值为-1，向下移动一个单位
					{
						D[m1][m2].dir = 1;
						break;
					}
					if (j - m2 == -1)//指引值为 2，向左移动一个单位
					{
						D[m1][m2].dir = 2;
						break;
					}
					if (j - m2 == 1)//指引值为 -2，向右移动一个单位
					{
						D[m1][m2].dir = -2;
						break;
					}
					break;
				}
				if (D[i][j].num == k - 1)//辅助跳出多重循环，剩下同理
					break;

			}
			if (D[i][j].num == k - 1)
				break;
		}
	}
}
void display()//将dir值转换为新坐标
{
	int i = 1, j = 1, n = 2;
	for (n = 2; n <= *p; n++)//按照序号前后进行寻找，不然会发生重叠现象，长度会被减短。
	{
		for (i = 1; i < W - 1; i++)
		{
			for (j = 1; j < L - 1; j++)
			{
				if (D[i][j].num == n)//找到n
				{
					if (D[i][j].dir == 1)//dir为1，向上平移一个单位，余下同理
					{
						D[i - 1][j].attribute = 3;
						D[i - 1][j].num = n;
						D[i - 1][j].dir = 0;
						D[i][j].attribute = 0;//将原有坐标属性清零
						D[i][j].num = 0;
						D[i][j].dir = 0;

					}
					if (D[i][j].dir == -1)
					{
						D[i + 1][j].attribute = 3;
						D[i + 1][j].num = n;
						D[i + 1][j].dir = 0;
						D[i][j].attribute = 0;
						D[i][j].num = 0;
						D[i][j].dir = 0;
					}
					if (D[i][j].dir == 2)
					{
						D[i][j-1].attribute = 3;
						D[i][j-1].num = n;
						D[i][j-1].dir = 0;
						D[i][j].attribute = 0;
						D[i][j].num = 0;
						D[i][j].dir = 0;
					}
					if (D[i][j].dir == -2)
					{
						D[i][j + 1].attribute = 3;
						D[i][j + 1].num = n;
						D[i][j + 1].dir = 0;
						D[i][j].attribute = 0;
						D[i][j].num = 0;
						D[i][j].dir = 0;
					}
				}
			}

		}
	}
}
//已完成
void res()//蛇尾判定函数
{
	judge();//首先使用judge，使每个蛇点坐标带有dir值
	*p = *p + 1;//蛇长度加1
	int i = 1, j = 1;
	if (*p - 1 > 1)//最初num为2.无蛇尾，加上辅助判定。
	{
		for (i = 1; i < W - 1; i++)
		{
			for (j = 1; j < L - 1; j++)
			{
				if (D[i][j].num == *p - 1)//找到蛇倒数第二个点
				{
					if (D[i][j].dir == 1)//蛇尾的dir值应该和倒数第二个点保持一致，余下同理
					{
						D[i + 1][j].attribute = 3;
						D[i + 1][j].num = *p;
						D[i + 1][j].dir = 1;
					}

					if (D[i][j].dir == -1)
					{
						D[i - 1][j].attribute = 3;
						D[i - 1][j].num = *p;
						D[i - 1][j].dir = -1;
					}

					if (D[i][j].dir == 2)
					{
						D[i][j + 1].attribute = 3;
						D[i][j + 1].num = *p;
						D[i][j + 1].dir = 2;
					}

					if (D[i][j].dir == -2)
					{
						D[i][j - 1].attribute = 3;
						D[i][j - 1].num = *p;
						D[i][j - 1].dir = -2;
					}
				}
			}
		}
	}
}
//已完成
void determine()//蛇头判定
{
	int i = 1, j = 1;
	int x = 0, y = 0;
	int mid = 0;
	for (i = 1; i < W - 1; i++)//把num为1的坐标初始化
	{
		for (j = 0; j < L - 1; j++)
		{
			if (D[i][j].num == 1)
				D[i][j].num = 0;

		}
	}

	for (i = 1; i < W - 1; i++)//找到坐标num为2的 记下x,y
	{
		for (j = 0; j < L - 1; j++)
		{
			if (D[i][j].num == 2)
			{
				x = j;
				y = i;
				break;
			}
		}
	}

	mid = put();//输入

	if (mid == 1)//通过输入值判断
	{
		if (D[y - 1][x].attribute == 0)//若虚拟蛇头点坐标attribute值为0，前进
		{
			D[y - 1][x].num = 1;
			D[y - 1][x].attribute = 4;
			judge();
		}
		if (D[y - 1][x].attribute == 1)//若虚拟蛇头点attribute值为1，运行res函数
		{
			D[y - 1][x].attribute = 0;
			D[y - 1][x].num = 1;
			res();
		}
		if (D[y - 1][x].attribute == 2)//若虚拟蛇头点attribute值为2，撞墙，游戏结束
		{	
			printf("Game Over");
			exit(0);
		}
		if (D[y - 1][x].attribute == 3)//若虚拟蛇头点attribute值为3，吃到自身，游戏结束
		{
			printf("Game Over");
			exit(0);
		}
	}
	if (mid == -1)//余下与上同理
	{
		if (D[y + 1][x].attribute == 0)
		{
			D[y + 1][x].num = 1;
			D[y + 1][x].attribute = 4;
			judge();
		}
		if (D[y + 1][x].attribute == 1)
		{
			D[y + 1][x].attribute = 0;
			D[y + 1][x].num = 1;
			res();
		}
		if (D[y + 1][x].attribute == 2)
		{
			printf("Game Over");
			exit(0);
		}
		if (D[y + 1][x].attribute == 3)
		{
			printf("Game Over");
			exit(0);
		}
	}
	if (mid == 2)
	{
		if (D[y][x - 1].attribute == 0)
		{
			D[y][x - 1].num = 1;
			D[y][x - 1].attribute = 4;
			judge();
		}
		if (D[y][x - 1].attribute == 1)
		{
			D[y][x - 1].attribute = 0;
			D[y][x - 1].num = 1;
			res();
		}
		if (D[y][x - 1].attribute == 2)
		{
			printf("Game Over");
			exit(0);
		}
		if (D[y][x - 1].attribute == 3)
		{
			printf("Game Over");
			exit(0);
		}
	}
	if (mid == -2)
	{
		if (D[y][x + 1].attribute == 0)
		{
			D[y][x + 1].num = 1;
			D[y][x + 1].attribute = 4;
			judge();
		}
		if (D[y][x + 1].attribute == 1)
		{
			D[y][x + 1].attribute = 0;
			D[y][x + 1].num = 1;
			res();
		}
		if (D[y][x + 1].attribute == 2)
		{
			printf("Game Over");
			exit(0);
		}
		if (D[y][x + 1].attribute == 3)
		{
			printf("Game Over");
			exit(0);
		}
	}
}
void print()//通过各点的attribute值来打印该点
{
	system("cls");
	int x = 0, y = 0;
	for (; y< W; y++)
	{
		for (x = 0; x < L; x++)
		{
			if (D[y][x].attribute == 0)
				printf(" ");
			if (D[y][x].attribute == 1)
				printf("C");
			if (D[y][x].attribute == 2)
				printf("B");
			if (D[y][x].attribute == 3)
				printf("A");
			if (x == 39)
				printf("\n");
		}


	}
}
//已完成

void init()//初始化函数
{
	int x = 0, y = 0; //初始化
	system("cls");
	for (y = 0; y < W; y++)//初次赋值
	{
		for (x = 0; x<L; x++)
		{
			D[y][x].attribute = 0;
			if (y == 0 || y == 19)//墙壁
			{
				D[y][x].attribute = 2;
			}
			if (x == 0 || x == 39)//墙壁
			{
				D[y][x].attribute = 2;
			}

		}
	}
	D[1][1].attribute = 3;
	D[1][1].num = 2;//初始化蛇头
	*p = 2;//初始化长度（包括虚拟蛇头，所以为2）
}
void game()
{
	while (true)//通过while true加sleep实现刷新
	{
		ran();//创建随机的食物坐标
		determine();//判断蛇头
		display();//转换坐标
		print();//打印方向
		Sleep(1);
	}



}
//已完成
//已完成
void guide()//指引
{
	int j = 0;
	int input = 0;

	for (j = 0; j < 10; j++)//有十次选择机会，通过输入的input进行选择
	{
		printf(" \n   1--进入游戏\n");
		printf("   2--游戏说明\n");
		printf("   3--退出游戏\n");
		scanf_s("%d", &input);
		getchar();
		if (input == 1)
		{
			init();
			game();
			break;
		}
		if (input == 2)
		{
			printf("通过WASD四键进行对贪吃蛇的位置控制（小写）");
			getchar();
			system("cls");
			guide();
		}
		if (input == 3)
			exit(0);
		else
		{
			printf("输入错误");
			getchar();
			system("cls");
		}
	}



}
//已完成
int main()//主函数调用guide函数
{
	guide();
	return 0;
}
//已完成
